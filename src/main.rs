// etherhosts: create hosts and ethers files from CSV
// By David Atkinson 2021
// CSV parsing is primitive, but should handle quoted strings

use std::env;
use std::fs; 
use chrono::{DateTime, Local};

fn process_csv_line(mut line: String) -> Vec<String> {                  // This function splits a CSV line at commas, and handles basic quoted text
    // Replace "" with space, and store the location
    let mut ddq = Vec::<usize>::new();   
    let mut f = line.find("\"\"");
    while f.is_some() {
        let i = f.unwrap();
        ddq.push(i);
        line.replace_range(i..=i+1, " ");
        f = line.find("\"\"");
    }

    // Now there is only single (bounding) quotes and commas, it's easier to parse
    // e.g. cell1,"cell2, with comma",cell3    
    let mut quoted: bool = false;
    let mut cells = Vec::<String>::new();
    let mut cell = String::new();
    
    for (i, b) in line.into_bytes().iter().enumerate() {
        let c = *b as char;
        if c == '"' {
            quoted = !quoted;
        } else if !quoted && c == ',' {
            cells.push(cell.clone());
            cell.clear();
        } else if ddq.contains(&i) {    // put the " back in
            cell.push('"');
        } else {
            cell.push(c);
        }
    }

    cells.push(cell);
    
    return cells;
}


fn main() {
    // display program info
    println!("etherhosts: Create hosts and ethers files from CSV");
    println!("usage: etherhosts [etherhosts.csv] [hosts] [ethers]");
    println!("");

    // filenames
    let mut inputfile = "etherhosts.csv";
    let mut hostsfile = "hosts";
    let mut ethersfile = "ethers";

    // get filenames from command line
    let args: Vec<String> = env::args().collect();
    if args.len() >= 2 {
        inputfile = &args[1];
    }
    if args.len() >= 3 {
        hostsfile = &args[2];
    }
    if args.len() >= 4 {
        ethersfile = &args[3];
    }

    // read input file
    let input = fs::read_to_string(inputfile).expect("Unable to open input file");
    let mut lines = input.lines();

    // read first line to determine positions of each column
    let header_row = process_csv_line(lines.next().expect("Input file didn't have a single line!").to_string());
    let mut ipaddrcol: usize = 0;
    let mut hostnamecol: usize = 0;
    let mut maccol: usize = 0;
    let mut found_i = false;
    let mut found_h = false;
    let mut found_m = false;

    for (c, field) in header_row.iter().enumerate() {
        if field == "ipaddr" {
            found_i = true;
            ipaddrcol = c;
        } else if field == "hostname" {
            found_h = true;
            hostnamecol = c;
        } else if field == "mac" {
            found_m = true;
            maccol = c;
        }
    }

    if !(found_i && found_h && found_m) {
        println!("Couldn't find all the headers: ipaddr, hostname, mac");
        return;
    }

    println!("Processing input file: {}", inputfile);

    // store hosts and ethers in strings
    let mut hoststxt = String::new();
    let mut etherstxt = String::new();

    // header for hosts and ethers files
    let now: DateTime<Local> = Local::now();
    let timestr = now.format("%F %T %Z");

    hoststxt.push_str(&format!("# hosts automatically generated by etherhosts {}\n", &timestr));
    etherstxt.push_str(&format!("# ethers automatically generated by etherhosts {}\n", &timestr));

    // process each line of the input file
    for (r,line) in lines.enumerate() {
        let fields = process_csv_line(line.to_string());

        // add to hosts, if we have all the data for it
        if fields[ipaddrcol].len() > 0 && fields[hostnamecol].len() > 0 {
            let hostline = format!("{} {}\n", fields[ipaddrcol], fields[hostnamecol]);
            hoststxt.push_str(&hostline);
        } else {
            println!("Missing ipaddr or hostname at line {}, hosts skipping this line", r+2);
        }

        // add to ethers, if we have all the data for it
        if fields[maccol].len() > 0 && fields[ipaddrcol].len() > 0 {
            let etherline = format!("{} {}\n", fields[maccol], fields[ipaddrcol]);
            etherstxt.push_str(&etherline);
        } else {
            println!("Missing mac or ipaddr at line {}, ethers skipping this line", r+2);
        }
    }

    // write to output files
    if fs::write(hostsfile, hoststxt).is_err() {
        println!("Unable to write to hosts file");
    }
    if fs::write(ethersfile, etherstxt).is_err() {
        println!("Unable to write to ethers file");
    }

}
