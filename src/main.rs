// etherhosts: create hosts and ethers files from CSV
// By David Atkinson 2021
// CSV parsing is primitive, but should handle quoted strings

use std::env;
use std::fs; 
use chrono::{DateTime, Local};
use regex::Regex;

fn process_csv_line(mut line: String) -> Vec<String> {                  // This function splits a CSV line at commas, and handles basic quoted text
    // Replace "" with space, and store the location
    let mut ddq = Vec::<usize>::new();   
    let mut f = line.find("\"\"");
    while f.is_some() {
        let i = f.unwrap();
        ddq.push(i);
        line.replace_range(i..=i+1, " ");
        f = line.find("\"\"");
    }

    // Now there is only single (bounding) quotes and commas, it's easier to parse
    // e.g. cell1,"cell2, with comma",cell3    
    let mut quoted: bool = false;
    let mut cells = Vec::<String>::new();
    let mut cell = String::new();
    
    for (i, b) in line.into_bytes().iter().enumerate() {
        let c = *b as char;
        if c == '"' {
            quoted = !quoted;
        } else if !quoted && c == ',' {
            cells.push(cell.clone());
            cell.clear();
        } else if ddq.contains(&i) {    // put the " back in
            cell.push('"');
        } else {
            cell.push(c);
        }
    }

    cells.push(cell);
    
    return cells;
}

fn clean_ipaddr(s: &str) -> String {
	let rs = s.trim();
	if valid_ipaddr(rs) {
		return rs.to_string();
	} else {
		return "".to_string();
	}
}

fn valid_ipaddr(s: &str) -> bool {
	let re = Regex::new(r"^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.)){3}(25[0-5]|(2[0-4]|1\d|[1-9]|)\d)$").unwrap();	
	return re.is_match(s);
}

fn clean_mac(s: &str) -> String {
	// convert windows hyphens into colons
	let rs: String = s.trim().chars().map(|c| 
		if c=='-' { 
			return ':';
		} else {
			return c;
		}
	).collect();
	
	if valid_mac(&rs) {
		return rs;
	} else {
		return "".to_string();
	}
}

fn valid_mac(s: &str) -> bool {
	let re = Regex::new(r"^[a-fA-F0-9]{2}(:[a-fA-F0-9]{2}){5}$").unwrap();
	return re.is_match(s);
}

fn clean_hostname(s: &str) -> String {
	let rs: String = s.trim().to_string();

	if valid_hostname(&rs) {
		return rs;
	} else {
		return "".to_string();
	}
}

fn valid_hostname(s: &str) -> bool {
	// it doesn't need to be perfect, just needs to filter out obvious mistakes
	let re = Regex::new(r"^([a-zA-Z0-9-\. ]*)$").unwrap();
	return re.is_match(s);	
}

fn main() {
    // display program info
    println!("etherhosts: Create hosts and ethers files from CSV");
    println!("usage: etherhosts [etherhosts.csv] [hosts] [ethers]");
    println!("");

    // filenames
    let mut inputfile = "etherhosts.csv";
    let mut hostsfile = "hosts";
    let mut ethersfile = "ethers";

    // get filenames from command line
    let args: Vec<String> = env::args().collect();
    if args.len() >= 2 {
        inputfile = &args[1];
    }
    if args.len() >= 3 {
        hostsfile = &args[2];
    }
    if args.len() >= 4 {
        ethersfile = &args[3];
    }

    // read input file
    let input = fs::read_to_string(inputfile).expect("Unable to open input file");
    let mut lines = input.lines();

    // read first line to determine positions of each column
    let header_row = process_csv_line(lines.next().expect("Input file didn't have a single line!").to_string());
    let mut ipaddrcol: usize = 0;
    let mut hostnamecol: usize = 0;
    let mut maccol: usize = 0;
    let mut found_i = false;
    let mut found_h = false;
    let mut found_m = false;

    for (c, field) in header_row.iter().enumerate() {
        if field == "ipaddr" {
            found_i = true;
            ipaddrcol = c;
        } else if field == "hostname" {
            found_h = true;
            hostnamecol = c;
        } else if field == "mac" {
            found_m = true;
            maccol = c;
        }
    }

    if !(found_i && found_h && found_m) {
        println!("Couldn't find all the headers: ipaddr, hostname, mac");
        return;
    }

    println!("Processing input file: {}", inputfile);

    // store hosts and ethers in strings
    let mut hoststxt = String::new();
    let mut etherstxt = String::new();

    // header for hosts and ethers files
    let now: DateTime<Local> = Local::now();
    let timestr = now.format("%F %T %Z");

    hoststxt.push_str(&format!("# hosts automatically generated by etherhosts {}\n", &timestr));
    etherstxt.push_str(&format!("# ethers automatically generated by etherhosts {}\n", &timestr));

    // process each line of the input file
    for (r,line) in lines.enumerate() {
        let fields = process_csv_line(line.to_string());

		let ipaddr = clean_ipaddr(&fields[ipaddrcol]);
		let hostname = clean_hostname(&fields[hostnamecol]);
		let mac = clean_mac(&fields[maccol]);

		if ipaddr.len() == 0 {
			println!("Invalid ipaddr at line {}, skipping this line", r+2);
			continue;
		}

        // add to hosts, if we have all the data for it
        if hostname.len() > 0 {
            let hostline = format!("{} {}\n", ipaddr, hostname);
            hoststxt.push_str(&hostline);
        } else {
            println!("Invalid hostname at line {}, hosts skipping this line", r+2);
        }

        // add to ethers, if we have all the data for it
        if mac.len() > 0 {
            let etherline = format!("{} {}\n", mac, ipaddr);
            etherstxt.push_str(&etherline);
        } else {
            println!("Invalid mac at line {}, ethers skipping this line", r+2);
        }
    }

    // write to output files
    if fs::write(hostsfile, hoststxt).is_err() {
        println!("Unable to write to hosts file");
    }
    if fs::write(ethersfile, etherstxt).is_err() {
        println!("Unable to write to ethers file");
    }

}
